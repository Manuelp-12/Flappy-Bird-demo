<!DOCTYPE html>
<html>
<head>
    <title>Flappy AI</title>
    <script src="./neataptic.js"></script>
    <style>
        canvas { border: 1px solid black; }
    </style>
</head>
<body>
    <div id="scoreboard" style="display: flex; justify-content: space-between; width: 300px">
        <div>Generation: <span id="generation">1</span></div>
        <div>Score: <span id="score">0</span></div>
        <div>High: <span id="high">0</span></div>
    </div>
    <canvas id="gameCanvas" width="300" height="300"></canvas>

    <script>
    const canvas = document.getElementById("gameCanvas");
    const context = canvas.getContext("2d");

    const birdSize = 10;
    const pipeWidth = 20;
    const pipeGap = 65;
    const jumpHeight = -3.75;
    const gravity = 0.15;
    const pipeSpeed = 1.5;
    const pipeSpawnInterval = 90;

    let pipes = [];
    let birds = [];
    let frame = 0;
    let generation = 1;

    let displayScore = 0;
    let bestDisplayScore = 0;

    const { Neat, Network, methods, architect } = neataptic;
    const populationSize = 50;

    const neat = new Neat(
        3, 1, null,
        {
            mutation: methods.mutation.ALL,
            popsize: populationSize,
            mutationRate: 0.3,
            elitism: Math.round(0.1 * populationSize),
            network: new architect.Perceptron(3, 6, 1)
        }
    );

    class Bird {
        constructor(brain) {
            this.x = 85;
            this.y = 150;
            this.vy = 0;
            this.alive = true;
            this.score = 0;
            this.brain = brain;
        }

        think() {
            const nextPipe = pipes.find(p => p[0].x + pipeWidth > this.x);
            if (!nextPipe) return;

            const pipeX = nextPipe[0].x;
            const topPipeBottomY = nextPipe[0].height;
            const bottomPipeTopY = nextPipe[1].y;

            const inputs = [
                (pipeX - this.x) / canvas.width,
                (this.y - topPipeBottomY) / canvas.height,
                (this.y - bottomPipeTopY) / canvas.height
            ];

            const output = this.brain.activate(inputs);
            if (output[0] > 0.5) {
                this.vy = jumpHeight;
            }
        }

        update() {
            this.y += this.vy;
            this.vy += gravity;
            this.score++;
        }

        draw() {
            context.fillStyle = "yellow";
            context.strokeStyle = "black";
            context.fillRect(this.x, this.y, birdSize, birdSize);
            context.strokeRect(this.x, this.y, birdSize, birdSize);
        }

        isDead() {
            if (this.y < 0 || this.y + birdSize > canvas.height) return true;
            return pipes.some(pipe => collision(this, pipe[0]) || collision(this, pipe[1]));
        }
    }

    function collision(bird, pipe) {
        return bird.x < pipe.x + pipeWidth &&
               bird.x + birdSize > pipe.x &&
               bird.y < pipe.y + pipe.height &&
               bird.y + birdSize > pipe.y;
    }

    function resetPipes() {
        pipes = [];
        addPipe();
    }

    function addPipe() {
        const totalHeight = canvas.height;
        const pipeTopHeight = Math.round(Math.random() * (totalHeight - 100) + 25);
        const pipeBottomY = pipeTopHeight + pipeGap;
        const pipeBottomHeight = totalHeight - pipeBottomY;

        pipes.push([
            { x: canvas.width, y: 0, height: pipeTopHeight },
            { x: canvas.width, y: pipeBottomY, height: pipeBottomHeight },
            false //add flag to track if pipe was passed
        ]);
    }

    function drawPipes() {
        context.fillStyle = "darkgreen";
        context.strokeStyle = "black";
        for (let pipePair of pipes) {
            for (let pipe of pipePair.slice(0, 2)) {
                context.fillRect(pipe.x, pipe.y, pipeWidth, pipe.height);
                context.strokeRect(pipe.x, pipe.y, pipeWidth, pipe.height);
            }
        }
    }

    function updatePipes() {
        for (let pipePair of pipes) {
            pipePair[0].x -= pipeSpeed;
            pipePair[1].x -= pipeSpeed;

            // Check if pipe was passed
            if (!pipePair[2] && pipePair[0].x + pipeWidth < 85) {
                pipePair[2] = true;
                displayScore++;
                document.getElementById("score").innerText = displayScore;
                if (displayScore > bestDisplayScore) {
                    bestDisplayScore = displayScore;
                    document.getElementById("high").innerText = bestDisplayScore;
                }
            }
        }

        if (pipes.length > 0 && pipes[0][0].x + pipeWidth < 0) {
            pipes.shift();
        }

        frame++;
        if (frame % pipeSpawnInterval === 0) {
            addPipe();
        }
    }

    function startGeneration() {
        document.getElementById("generation").innerText = generation;
        displayScore = 0;
        document.getElementById("score").innerText = "0";
        frame = 0;
        resetPipes();
        birds = neat.population.map(genome => new Bird(genome));
        requestAnimationFrame(gameLoop);
    }

    function endGeneration() {
        birds.forEach((bird, i) => {
            neat.population[i].score = bird.score;
        });

        generation++;
        neat.evolve().then(startGeneration);
    }

    function gameLoop() {
        context.fillStyle = "#87CEEB";
        context.fillRect(0, 0, canvas.width, canvas.height);

        drawPipes();
        updatePipes();

        let allDead = true;
        for (let bird of birds) {
            if (!bird.alive) continue;

            bird.think();
            bird.update();
            bird.draw();

            if (bird.isDead()) {
                bird.alive = false;
            } else {
                allDead = false;
            }
        }

        if (allDead) {
            endGeneration();
        } else {
            requestAnimationFrame(gameLoop);
        }
    }

    startGeneration();
    </script>
</body>
</html>
